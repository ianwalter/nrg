const path = require('path')
const fs = require('fs')
const { print } = require('@ianwalter/print')
const requireFromString = require('require-from-string')
const devalue = require('devalue')
const pkgDir = require('pkg-dir')
const cloneable = require('@ianwalter/cloneable')
const createUrl = require('@ianwalter/url')

const appModule = module.parent.parent.parent || module.parent.parent
const mainDir = pkgDir.sync(appModule.filename)
const defaultSsrOptions = {
  entry: path.join(mainDir, 'dist/ssr.js'),
  template: path.join(__dirname, '../pageTemplate.html')
}

function serveSsr (options) {
  // Merge the given options with the default options.
  options = Object.assign({}, defaultSsrOptions, options)

  return async (ctx, next) => {
    if (ctx.cfg.isProd && !options.renderer) {
      // Create the page renderer that will be used by the middleware if it
      // wasn't given on initialization.
      try {
        if (!options.page) {
          options.page = fs.readFileSync(options.template, 'utf8')
        }
        options.renderer = require(options.entry).default(options.page)
      } catch (err) {
        print.warn(err)
      }
    } else if (!ctx.cfg.isProd) {
      // If not in production mode, use the renderer generated by Webpack so
      // that it can be changed without having to restart the server.
      const fs = ctx.webpack.fileSystem
      const entry = fs.readFileSync(options.entry, 'utf8')
      options.page = fs.readFileSync(options.template, 'utf8')
      options.renderer = requireFromString(entry).default(options.page)
    }

    // Add the "full" URL on the context so that a router can use it with the
    // URL class.
    ctx.fullUrl = createUrl(ctx.cfg.baseUrl, ctx.url)

    // TODO: comment
    const result = await options.renderer(ctx, next)

    if (typeof result === 'string') {
      // If a string was returned instead of a page object, redirect to it as a
      // URL.
      ctx.log.debug(`serveSsr -> Redirecting to ${result}`)
      return ctx.redirect(result)
    } else if (!result) {
      // If result is falsy, e.g. a 404 page isn't even returned, assume next
      // was called to continue to the next middleware so don't try to render a
      // page.
      return
    }

    // If the response body has not already been set, construct the HTML
    // document that will be served.
    if (!ctx.body) {
      let { status, head = '', css = { code: '' }, html = '', ssr } = result

      // If SSR data was provided, embed it into the page so that it can be used
      // when the client-side application boots and removed from the page if
      // necessary.
      if (ssr) {
        // Use cloneable to remove any functions from the ssr object.
        ssr = cloneable(ssr)
        ctx.log.debug(ssr, 'serveSsr -> SSR data')
        head += `
          <script id="ssrData" type="text/javascript">
            window.__SSR_DATA__ = ${devalue(ssr)}
          </script>
        `
      }

      // If a status was returned, set it (to something other than 200).
      if (status) {
        ctx.status = status
      }

      // Replace the placeholders on the base page template with the code return
      // by the end-user's SSR entry.
      ctx.body = options.page
        .replace('<!-- head-outlet -->', head)
        .replace('/* css-outlet */', css.code)
        .replace('<!-- html-outlet -->', html)
    }
  }
}

module.exports = { serveSsr }
