const path = require('path')
const fs = require('fs')
const { print } = require('@ianwalter/print')
const requireFromString = require('require-from-string')

const mainDir = path.dirname(process.mainModule.filename)
const defaultSsrOptions = {
  entry: path.join(mainDir, 'dist/ssr.js'),
  template: path.join(__dirname, '../pageTemplate.html')
}

function serveSsr (options) {
  // Merge the given options with the default options.
  options = Object.assign({}, defaultSsrOptions, options)

  return async (ctx, next) => {
    if (ctx.isProduction && !options.renderer) {
      // Create the page renderer that will be used by the middleware if it
      // wasn't given on initialization.
      try {
        if (!options.page) {
          options.page = fs.readFileSync(options.template, 'utf8')
        }
        options.renderer = require(options.entry).default(options.page)
      } catch (err) {
        print.warn(err)
      }
    } else if (!ctx.isProduction) {
      // If not in production mode, use the renderer generated by Webpack so
      // that it can be changed without having to restart the server.
      ctx.log.debug(ctx, 'state')
      const entry = ctx.state.fs.readFileSync(options.entry, 'utf8')
      options.page = ctx.state.fs.readFileSync(options.template, 'utf8')
      options.renderer = requireFromString(entry).default(options.page)
    }

    // Add the "full" URL on the context so that a router can use it with the
    // URL class.
    ctx.fullUrl = ctx.baseUrl + ctx.url

    // Render the app to the response body.
    ctx.body = await options.renderer(ctx)
  }
}

module.exports = { serveSsr }
